---
title: "Building Real Robots in Python – Packages, Workspaces, Launch, rclpy Mastery"
description: "Comprehensive guide to developing robotic applications in Python using ROS 2, covering packages, workspaces, launch files, and advanced rclpy programming techniques."
tags: ["ros2", "python", "rclpy", "packages", "workspaces", "launch"]
sidebar_label: "Chapter 4: Building Real Robots in Python"
slug: "/modules/module1/chapter4"
keywords: ["ROS 2 Python", "rclpy", "ROS 2 Packages", "Launch Files", "Robot Development"]
---

# Building Real Robots in Python – Packages, Workspaces, Launch, rclpy Mastery

## Learning Objectives

By the end of this chapter, you will be able to:
- Create and structure ROS 2 Python packages following best practices
- Organize code in workspaces with proper dependencies and build configurations
- Write comprehensive launch files for complex robotic systems
- Master advanced rclpy programming techniques for real-world applications
- Implement robust error handling and debugging strategies in Python nodes

## Introduction

Python has become one of the most popular languages for robotics development due to its simplicity, extensive libraries, and strong integration with machine learning frameworks. ROS 2's Python client library, rclpy, provides a powerful yet accessible interface for building sophisticated robotic applications. This chapter provides a comprehensive guide to developing real robots in Python, covering everything from package structure and workspace organization to advanced programming techniques and debugging strategies.

## ROS 2 Python Package Structure

### Creating a Python Package

A ROS 2 Python package follows a specific structure that enables proper dependency management and distribution:

```
my_robot_package/
├── package.xml          # Package metadata and dependencies
├── CMakeLists.txt       # Build configuration (minimal for Python-only packages)
├── setup.py             # Python package configuration
├── setup.cfg            # Installation configuration
├── my_robot_package/    # Main Python module
│   ├── __init__.py      # Package initialization
│   ├── robot_controller.py
│   ├── sensor_processor.py
│   └── utils/
│       ├── __init__.py
│       └── helpers.py
├── launch/              # Launch files
│   ├── robot.launch.py
│   └── navigation.launch.py
├── config/              # Configuration files
│   └── robot_params.yaml
├── test/                # Unit tests
│   └── test_robot_controller.py
└── README.md            # Package documentation
```

### Package.xml Configuration

The `package.xml` file defines package metadata and dependencies:

```xml
<?xml version="1.0"?>
<?xml-model href="http://download.ros.org/schema/package_format3.xsd" schematypens="http://www.w3.org/2001/XMLSchema"?>
<package format="3">
  <name>my_robot_package</name>
  <version>0.0.1</version>
  <description>Python package for controlling and operating my robot</description>
  <maintainer email="maintainer@todo.todo">maintainer</maintainer>
  <license>Apache-2.0</license>

  <exec_depend>rclpy</exec_depend>
  <exec_depend>std_msgs</exec_depend>
  <exec_depend>sensor_msgs</exec_depend>
  <exec_depend>geometry_msgs</exec_depend>
  <exec_depend>nav_msgs</exec_depend>

  <test_depend>ament_copyright</test_depend>
  <test_depend>ament_flake8</test_depend>
  <test_depend>ament_pep257</test_depend>
  <test_depend>python3-pytest</test_depend>

  <export>
    <build_type>ament_python</build_type>
  </export>
</package>
```

### Setup.py Configuration

The `setup.py` file configures the Python package:

```python
from setuptools import setup
from glob import glob
import os

package_name = 'my_robot_package'

setup(
    name=package_name,
    version='0.0.1',
    packages=[package_name],
    data_files=[
        ('share/ament_index/resource_index/packages',
            ['resource/' + package_name]),
        ('share/' + package_name, ['package.xml']),
        # Include all launch files
        (os.path.join('share', package_name, 'launch'), glob('launch/*.py')),
        # Include all config files
        (os.path.join('share', package_name, 'config'), glob('config/*.yaml')),
    ],
    install_requires=['setuptools'],
    zip_safe=True,
    maintainer='maintainer',
    maintainer_email='maintainer@todo.todo',
    description='Python package for controlling and operating my robot',
    license='Apache-2.0',
    tests_require=['pytest'],
    entry_points={
        'console_scripts': [
            'robot_controller = my_robot_package.robot_controller:main',
            'sensor_processor = my_robot_package.sensor_processor:main',
        ],
    },
)
```

### Python Module Structure

A well-structured Python module follows these principles:

```python
# my_robot_package/__init__.py
"""Main package for my robot functionality."""

from .robot_controller import RobotController
from .sensor_processor import SensorProcessor

__all__ = ['RobotController', 'SensorProcessor']

# my_robot_package/robot_controller.py
import rclpy
from rclpy.node import Node
from geometry_msgs.msg import Twist
from sensor_msgs.msg import LaserScan
from rclpy.qos import QoSProfile, QoSReliabilityPolicy, QoSHistoryPolicy

class RobotController(Node):
    """Advanced robot controller with obstacle avoidance and navigation."""

    def __init__(self):
        super().__init__('robot_controller')

        # Configuration parameters
        self.declare_parameter('linear_speed', 0.5)
        self.declare_parameter('angular_speed', 0.5)
        self.declare_parameter('safety_distance', 0.5)

        self.linear_speed = self.get_parameter('linear_speed').value
        self.angular_speed = self.get_parameter('angular_speed').value
        self.safety_distance = self.get_parameter('safety_distance').value

        # Publishers and subscribers
        self.cmd_vel_pub = self.create_publisher(Twist, 'cmd_vel', 10)
        self.scan_sub = self.create_subscription(
            LaserScan,
            'scan',
            self.scan_callback,
            qos_profile=QoSProfile(
                depth=10,
                reliability=QoSReliabilityPolicy.RELIABLE,
                history=QoSHistoryPolicy.KEEP_LAST
            )
        )

        # Timer for control loop
        self.control_timer = self.create_timer(0.1, self.control_loop)

        # Robot state
        self.obstacle_detected = False
        self.min_distance = float('inf')

        self.get_logger().info('Robot controller initialized')

    def scan_callback(self, msg):
        """Process laser scan data for obstacle detection."""
        # Filter out invalid ranges
        valid_ranges = [r for r in msg.ranges if 0.0 < r < float('inf')]

        if valid_ranges:
            self.min_distance = min(valid_ranges)
            self.obstacle_detected = self.min_distance < self.safety_distance
        else:
            self.min_distance = float('inf')
            self.obstacle_detected = False

    def control_loop(self):
        """Main control loop for robot navigation."""
        cmd_vel = Twist()

        if self.obstacle_detected:
            # Stop and turn to avoid obstacle
            cmd_vel.linear.x = 0.0
            cmd_vel.angular.z = self.angular_speed
        else:
            # Move forward
            cmd_vel.linear.x = self.linear_speed
            cmd_vel.angular.z = 0.0

        self.cmd_vel_pub.publish(cmd_vel)

def main(args=None):
    """Main entry point for the robot controller node."""
    rclpy.init(args=args)
    robot_controller = RobotController()

    try:
        rclpy.spin(robot_controller)
    except KeyboardInterrupt:
        robot_controller.get_logger().info('Node interrupted by user')
    finally:
        robot_controller.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
```

## Workspace Organization and Management

### Creating and Managing Workspaces

A ROS 2 workspace is a directory structure that contains multiple packages:

```bash
# Create workspace directory
mkdir -p ~/my_robot_ws/src

# Navigate to source directory
cd ~/my_robot_ws/src

# Clone or create packages in src directory
git clone https://github.com/user/my_robot_package.git
# Or create new package
ros2 pkg create --build-type ament_python my_new_package

# Build the workspace
cd ~/my_robot_ws
colcon build --packages-select my_robot_package

# Source the workspace
source install/setup.bash
```

### Workspace Best Practices

1. **Organize by functionality**: Group related packages together
2. **Use version control**: Each package should be in its own repository
3. **Document dependencies**: Clearly specify package dependencies
4. **Follow naming conventions**: Use lowercase with underscores
5. **Maintain separate workspaces**: Separate development, testing, and production

### Dependency Management

Proper dependency management ensures your packages work across different environments:

```python
# requirements.txt - External Python dependencies
numpy>=1.19.0
scipy>=1.5.0
opencv-python>=4.5.0
matplotlib>=3.3.0

# setup.py - ROS 2 dependencies
exec_depend tags in package.xml:
<exec_depend>python3-numpy</exec_depend>
<exec_depend>python3-scipy</exec_depend>
```

## Launch Files for Complex Systems

### Basic Launch File Structure

Launch files allow you to start multiple nodes with specific configurations:

```python
# launch/robot.launch.py
from launch import LaunchDescription
from launch.actions import DeclareLaunchArgument, LogInfo
from launch.substitutions import LaunchConfiguration, PathJoinSubstitution
from launch_ros.actions import Node
from launch_ros.substitutions import FindPackageShare
from launch.substitutions import TextSubstitution

def generate_launch_description():
    # Declare launch arguments
    use_sim_time = DeclareLaunchArgument(
        'use_sim_time',
        default_value='false',
        description='Use simulation time'
    )

    robot_name = DeclareLaunchArgument(
        'robot_name',
        default_value='my_robot',
        description='Name of the robot'
    )

    # Define nodes
    robot_controller = Node(
        package='my_robot_package',
        executable='robot_controller',
        name='robot_controller',
        parameters=[
            PathJoinSubstitution([
                FindPackageShare('my_robot_package'),
                'config',
                'robot_params.yaml'
            ]),
            {'robot_name': LaunchConfiguration('robot_name')},
            {'use_sim_time': LaunchConfiguration('use_sim_time')}
        ],
        remappings=[
            ('/cmd_vel', [LaunchConfiguration('robot_name'), '/cmd_vel']),
            ('/scan', [LaunchConfiguration('robot_name'), '/scan'])
        ],
        output='screen'
    )

    sensor_processor = Node(
        package='my_robot_package',
        executable='sensor_processor',
        name='sensor_processor',
        parameters=[{'use_sim_time': LaunchConfiguration('use_sim_time')}],
        output='screen'
    )

    # Return launch description
    return LaunchDescription([
        use_sim_time,
        robot_name,
        robot_controller,
        sensor_processor,
        LogInfo(msg=['Launching robot: ', LaunchConfiguration('robot_name')])
    ])
```

### Advanced Launch Features

```python
# launch/advanced_robot.launch.py
from launch import LaunchDescription
from launch.actions import (
    DeclareLaunchArgument,
    IncludeLaunchDescription,
    GroupAction,
    SetEnvironmentVariable
)
from launch.conditions import IfCondition, UnlessCondition
from launch.launch_description_sources import PythonLaunchDescriptionSource
from launch.substitutions import LaunchConfiguration, PythonExpression
from launch_ros.actions import Node, PushRosNamespace
from launch_ros.substitutions import FindPackageShare

def generate_launch_description():
    # Launch arguments
    use_sim_time = LaunchConfiguration('use_sim_time')
    robot_name = LaunchConfiguration('robot_name')
    enable_viz = LaunchConfiguration('enable_viz')

    # Conditional launch of visualization
    rviz_node = Node(
        package='rviz2',
        executable='rviz2',
        name='rviz2',
        arguments=['-d', PathJoinSubstitution([
            FindPackageShare('my_robot_package'),
            'rviz',
            'robot.rviz'
        ])],
        condition=IfCondition(enable_viz)
    )

    # Group nodes under a namespace
    robot_group = GroupAction(
        actions=[
            PushRosNamespace(robot_name),
            Node(
                package='my_robot_package',
                executable='robot_controller',
                name='controller',
                parameters=[{'use_sim_time': use_sim_time}]
            ),
            Node(
                package='my_robot_package',
                executable='sensor_processor',
                name='sensor_processor',
                parameters=[{'use_sim_time': use_sim_time}]
            )
        ]
    )

    # Include other launch files
    navigation_launch = IncludeLaunchDescription(
        PythonLaunchDescriptionSource([
            FindPackageShare('nav2_bringup'),
            '/launch/navigation_launch.py'
        ]),
        condition=IfCondition(
            PythonExpression([use_sim_time, ' == "true"'])
        )
    )

    return LaunchDescription([
        DeclareLaunchArgument('use_sim_time', default_value='false'),
        DeclareLaunchArgument('robot_name', default_value='my_robot'),
        DeclareLaunchArgument('enable_viz', default_value='true'),

        SetEnvironmentVariable('RCUTILS_LOGGING_USE_STDOUT', '1'),
        SetEnvironmentVariable('RCUTILS_LOGGING_BUFFERED_STREAM', '1'),

        robot_group,
        rviz_node,
        navigation_launch
    ])
```

### Configuration Files

YAML configuration files provide parameter management:

```yaml
# config/robot_params.yaml
/**:
  ros__parameters:
    # Robot physical properties
    wheel_radius: 0.05
    wheel_separation: 0.3
    max_linear_speed: 1.0
    max_angular_speed: 1.0

    # Sensor configuration
    laser_min_range: 0.1
    laser_max_range: 10.0
    camera_fov: 1.047  # 60 degrees in radians

    # Navigation parameters
    safety_distance: 0.5
    obstacle_threshold: 0.3
    approach_speed: 0.3

    # Control parameters
    linear_kp: 1.0
    angular_kp: 2.0
    control_frequency: 10.0

    # Debug parameters
    debug_mode: false
    log_level: "info"
```

## Advanced rclpy Programming Techniques

### Lifecycle Nodes

Lifecycle nodes provide controlled state transitions for complex robotic systems:

```python
import rclpy
from rclpy.lifecycle import LifecycleNode, LifecycleState, TransitionCallbackReturn
from rclpy.qos import QoSProfile
from std_msgs.msg import String

class LifecycleRobotController(LifecycleNode):
    """Robot controller with lifecycle management."""

    def __init__(self):
        super().__init__('lifecycle_robot_controller')
        self.get_logger().info('Lifecycle robot controller created, waiting for configuration')

    def on_configure(self, state: LifecycleState) -> TransitionCallbackReturn:
        """Configure the node."""
        self.get_logger().info(f'Configuring node, current state: {state.label}')

        # Create publishers and subscribers (but don't activate them yet)
        self.publisher = self.create_publisher(String, 'robot_status', 10)

        # Load parameters
        self.declare_parameter('control_frequency', 10)
        self.control_frequency = self.get_parameter('control_frequency').value

        # Initialize internal variables
        self.is_initialized = True

        return TransitionCallbackReturn.SUCCESS

    def on_activate(self, state: LifecycleState) -> TransitionCallbackReturn:
        """Activate the node."""
        self.get_logger().info(f'Activating node, current state: {state.label}')

        # Activate publishers/subscribers
        self.publisher.on_activate()

        # Create control timer
        self.control_timer = self.create_timer(
            1.0 / self.control_frequency,
            self.control_callback
        )

        return TransitionCallbackReturn.SUCCESS

    def on_deactivate(self, state: LifecycleState) -> TransitionCallbackReturn:
        """Deactivate the node."""
        self.get_logger().info(f'Deactivating node, current state: {state.label}')

        # Deactivate publishers/subscribers
        self.publisher.on_deactivate()

        # Cancel timer
        self.control_timer.cancel()

        return TransitionCallbackReturn.SUCCESS

    def on_cleanup(self, state: LifecycleState) -> TransitionCallbackReturn:
        """Clean up the node."""
        self.get_logger().info(f'Cleaning up node, current state: {state.label}')

        # Destroy publishers/subscribers
        self.destroy_publisher(self.publisher)
        self.destroy_timer(self.control_timer)

        return TransitionCallbackReturn.SUCCESS

    def on_shutdown(self, state: LifecycleState) -> TransitionCallbackReturn:
        """Shutdown the node."""
        self.get_logger().info(f'Shutting down node, current state: {state.label}')
        return TransitionCallbackReturn.SUCCESS

    def control_callback(self):
        """Control loop callback."""
        if self.is_initialized:
            msg = String()
            msg.data = f'Robot operational at {self.get_clock().now().nanoseconds}'
            self.publisher.publish(msg)

def main(args=None):
    rclpy.init(args=args)
    node = LifecycleRobotController()

    # Spin and handle lifecycle transitions
    rclpy.spin(node.get_node())

    node.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

### Multi-threaded Execution

For complex robotic systems requiring concurrent operations:

```python
import rclpy
from rclpy.node import Node
from rclpy.executors import MultiThreadedExecutor
from rclpy.callback_groups import MutuallyExclusiveCallbackGroup, ReentrantCallbackGroup
import threading
from std_msgs.msg import String
import time

class MultiThreadedRobotController(Node):
    """Robot controller using multi-threaded execution."""

    def __init__(self):
        super().__init__('multi_threaded_robot_controller')

        # Create different callback groups
        self.sensor_callback_group = MutuallyExclusiveCallbackGroup()
        self.control_callback_group = MutuallyExclusiveCallbackGroup()
        self.reentrant_group = ReentrantCallbackGroup()

        # Publishers and subscribers with different callback groups
        self.status_pub = self.create_publisher(
            String, 'robot_status', 10,
            callback_group=self.reentrant_group
        )

        self.sensor_sub = self.create_subscription(
            String, 'sensor_data', self.sensor_callback, 10,
            callback_group=self.sensor_callback_group
        )

        # Timers with different callback groups
        self.status_timer = self.create_timer(
            1.0, self.publish_status,
            callback_group=self.reentrant_group
        )

        self.control_timer = self.create_timer(
            0.1, self.control_loop,
            callback_group=self.control_callback_group
        )

        # Shared data with thread safety
        self._lock = threading.RLock()
        self.sensor_data = {}
        self.robot_state = {'position': [0, 0], 'orientation': 0}

        self.get_logger().info('Multi-threaded robot controller initialized')

    def sensor_callback(self, msg):
        """Handle sensor data (runs in sensor thread)."""
        with self._lock:
            self.sensor_data['raw'] = msg.data
            self.sensor_data['timestamp'] = self.get_clock().now().nanoseconds
        self.get_logger().debug(f'Sensor data received: {msg.data}')

    def control_loop(self):
        """Main control loop (runs in control thread)."""
        with self._lock:
            # Process sensor data and update robot state
            if 'raw' in self.sensor_data:
                # Process sensor data to update robot state
                self.robot_state['position'][0] += 0.01  # Simulate movement
                self.robot_state['orientation'] += 0.001  # Simulate rotation

    def publish_status(self):
        """Publish robot status (runs in main thread)."""
        with self._lock:
            status_msg = String()
            status_msg.data = f'Position: {self.robot_state["position"]}, ' \
                             f'Orientation: {self.robot_state["orientation"]:.3f}'
        self.status_pub.publish(status_msg)

def main(args=None):
    rclpy.init(args=args)

    node = MultiThreadedRobotController()

    # Use multi-threaded executor to handle concurrent callbacks
    executor = MultiThreadedExecutor(num_threads=4)
    executor.add_node(node)

    try:
        executor.spin()
    except KeyboardInterrupt:
        node.get_logger().info('Interrupted by user')
    finally:
        node.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
```

### Custom Message Types

Creating custom message types for specialized applications:

```python
# Custom message definition: msg/RobotCommand.msg
# In msg/RobotCommand.msg file:
float64 linear_velocity
float64 angular_velocity
bool emergency_stop
string command_id

# Usage in Python node:
from my_robot_package.msg import RobotCommand

class CommandProcessor(Node):
    def __init__(self):
        super().__init__('command_processor')

        self.command_sub = self.create_subscription(
            RobotCommand,
            'robot_command',
            self.command_callback,
            10
        )

        self.status_pub = self.create_publisher(
            String,  # Could also be a custom status message
            'command_status',
            10
        )

    def command_callback(self, msg):
        """Process custom robot command."""
        if msg.emergency_stop:
            self.emergency_stop()
        else:
            # Execute command
            self.execute_command(msg.linear_velocity, msg.angular_velocity)

        # Publish status
        status_msg = String()
        status_msg.data = f'Command {msg.command_id} executed'
        self.status_pub.publish(status_msg)
```

## Error Handling and Debugging

### Exception Handling in ROS 2 Nodes

Proper exception handling ensures robust operation:

```python
import rclpy
from rclpy.node import Node
from rclpy.exceptions import ParameterNotDeclaredException
import traceback

class RobustRobotController(Node):
    """Robot controller with comprehensive error handling."""

    def __init__(self):
        super().__init__('robust_robot_controller')

        # Initialize safely with error handling
        try:
            self.setup_parameters()
            self.setup_communication()
            self.setup_timers()
        except Exception as e:
            self.get_logger().error(f'Failed to initialize controller: {e}')
            self.get_logger().error(traceback.format_exc())
            raise

    def setup_parameters(self):
        """Safely set up parameters with defaults."""
        try:
            # Declare parameters with safe defaults
            self.declare_parameter('linear_speed', 0.5)
            self.declare_parameter('angular_speed', 0.5)
            self.declare_parameter('safety_distance', 0.5)

            # Get parameter values safely
            self.linear_speed = self.get_parameter('linear_speed').value
            self.angular_speed = self.get_parameter('angular_speed').value
            self.safety_distance = self.get_parameter('safety_distance').value

            # Validate parameter values
            if self.linear_speed <= 0:
                raise ValueError('Linear speed must be positive')
            if self.angular_speed <= 0:
                raise ValueError('Angular speed must be positive')
            if self.safety_distance <= 0:
                raise ValueError('Safety distance must be positive')

        except ParameterNotDeclaredException as e:
            self.get_logger().error(f'Parameter not declared: {e}')
            raise
        except ValueError as e:
            self.get_logger().error(f'Invalid parameter value: {e}')
            raise

    def setup_communication(self):
        """Safely set up publishers and subscribers."""
        try:
            from geometry_msgs.msg import Twist
            from sensor_msgs.msg import LaserScan

            self.cmd_vel_pub = self.create_publisher(Twist, 'cmd_vel', 10)
            self.scan_sub = self.create_subscription(
                LaserScan, 'scan', self.scan_callback, 10
            )
        except Exception as e:
            self.get_logger().error(f'Failed to setup communication: {e}')
            raise

    def scan_callback(self, msg):
        """Robust scan callback with error handling."""
        try:
            # Process scan data
            valid_ranges = [r for r in msg.ranges if 0.0 < r < float('inf')]

            if not valid_ranges:
                self.get_logger().warning('No valid ranges in scan data')
                return

            min_distance = min(valid_ranges)

            # Generate command based on scan
            cmd_vel = self.generate_command(min_distance)
            self.cmd_vel_pub.publish(cmd_vel)

        except Exception as e:
            self.get_logger().error(f'Error in scan callback: {e}')
            self.get_logger().error(traceback.format_exc())
            # Continue operation with safe command
            safe_cmd = self.get_safe_command()
            self.cmd_vel_pub.publish(safe_cmd)

    def generate_command(self, min_distance):
        """Generate movement command based on sensor data."""
        from geometry_msgs.msg import Twist

        cmd_vel = Twist()

        if min_distance < self.safety_distance:
            # Stop and turn
            cmd_vel.linear.x = 0.0
            cmd_vel.angular.z = self.angular_speed
        else:
            # Move forward
            cmd_vel.linear.x = self.linear_speed
            cmd_vel.angular.z = 0.0

        return cmd_vel

    def get_safe_command(self):
        """Return a safe command in case of errors."""
        from geometry_msgs.msg import Twist
        cmd_vel = Twist()
        cmd_vel.linear.x = 0.0  # Stop
        cmd_vel.angular.z = 0.0  # No rotation
        return cmd_vel

def main(args=None):
    rclpy.init(args=args)
    robot_controller = None

    try:
        robot_controller = RobustRobotController()
        rclpy.spin(robot_controller)
    except KeyboardInterrupt:
        if robot_controller:
            robot_controller.get_logger().info('Node interrupted by user')
    except Exception as e:
        if robot_controller:
            robot_controller.get_logger().error(f'Unhandled exception: {e}')
            robot_controller.get_logger().error(traceback.format_exc())
    finally:
        if robot_controller:
            robot_controller.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
```

### Debugging Techniques

Effective debugging strategies for ROS 2 Python nodes:

```python
# Debugging utilities
import rclpy
from rclpy.node import Node
import time
import functools
from typing import Callable

def debug_timing(func: Callable) -> Callable:
    """Decorator to measure function execution time."""
    @functools.wraps(func)
    def wrapper(self, *args, **kwargs):
        start_time = time.time()
        result = func(self, *args, **kwargs)
        end_time = time.time()
        execution_time = (end_time - start_time) * 1000  # Convert to milliseconds

        if hasattr(self, 'get_logger'):
            self.get_logger().debug(
                f'{func.__name__} executed in {execution_time:.2f}ms'
            )

        return result
    return wrapper

class DebugRobotController(Node):
    """Robot controller with debugging capabilities."""

    def __init__(self):
        super().__init__('debug_robot_controller')

        # Enable debug mode
        self.declare_parameter('debug_mode', False)
        self.debug_mode = self.get_parameter('debug_mode').value

        # Performance monitoring
        self.message_times = []
        self.last_message_time = time.time()

        # Setup communication
        from geometry_msgs.msg import Twist
        from sensor_msgs.msg import LaserScan

        self.cmd_vel_pub = self.create_publisher(Twist, 'cmd_vel', 10)
        self.scan_sub = self.create_subscription(
            LaserScan, 'scan', self.scan_callback, 10
        )

        # Debug timer
        self.debug_timer = self.create_timer(5.0, self.debug_report)

    @debug_timing
    def scan_callback(self, msg):
        """Scan callback with timing."""
        current_time = time.time()

        # Calculate message interval
        if hasattr(self, 'last_message_time'):
            interval = current_time - self.last_message_time
            self.message_times.append(interval)

            if len(self.message_times) > 100:  # Keep last 100 measurements
                self.message_times.pop(0)

        self.last_message_time = current_time

        # Process scan data
        cmd_vel = self.process_scan(msg)
        self.cmd_vel_pub.publish(cmd_vel)

        if self.debug_mode:
            self.get_logger().info(f'Scan callback processed {len(msg.ranges)} ranges')

    def process_scan(self, msg):
        """Process laser scan and return velocity command."""
        from geometry_msgs.msg import Twist

        cmd_vel = Twist()

        # Find minimum distance
        valid_ranges = [r for r in msg.ranges if 0.0 < r < float('inf')]

        if valid_ranges:
            min_distance = min(valid_ranges)

            if min_distance < 0.5:  # Safety distance
                cmd_vel.angular.z = 0.5  # Turn
            else:
                cmd_vel.linear.x = 0.5  # Move forward

        return cmd_vel

    def debug_report(self):
        """Print debug information."""
        if self.message_times:
            avg_interval = sum(self.message_times) / len(self.message_times)
            avg_frequency = 1.0 / avg_interval if avg_interval > 0 else 0

            self.get_logger().info(
                f'Message frequency: {avg_frequency:.2f} Hz, '
                f'Avg interval: {avg_interval*1000:.2f} ms'
            )

def main(args=None):
    rclpy.init(args=args)
    node = DebugRobotController()
    rclpy.spin(node)
    node.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

## Testing and Validation

### Unit Testing for ROS 2 Nodes

```python
# test/test_robot_controller.py
import unittest
import rclpy
from rclpy.executors import SingleThreadedExecutor
from my_robot_package.robot_controller import RobotController
from geometry_msgs.msg import Twist
from sensor_msgs.msg import LaserScan
import time

class TestRobotController(unittest.TestCase):
    @classmethod
    def setUpClass(cls):
        rclpy.init()

    @classmethod
    def tearDownClass(cls):
        rclpy.shutdown()

    def setUp(self):
        self.node = RobotController()
        self.executor = SingleThreadedExecutor()
        self.executor.add_node(self.node)

    def tearDown(self):
        self.node.destroy_node()

    def test_initialization(self):
        """Test that the node initializes correctly."""
        self.assertIsNotNone(self.node)
        self.assertEqual(self.node.linear_speed, 0.5)  # Default value

    def test_scan_processing(self):
        """Test that scan data is processed correctly."""
        # Create a mock laser scan message
        scan_msg = LaserScan()
        scan_msg.ranges = [1.0, 1.0, 0.3, 1.0, 1.0]  # Obstacle at 0.3m

        # Process the scan
        self.node.scan_callback(scan_msg)

        # Check that obstacle was detected
        self.assertTrue(self.node.obstacle_detected)
        self.assertLess(self.node.min_distance, 0.5)

    def test_control_behavior(self):
        """Test that control behavior changes based on sensor input."""
        # Test with obstacle
        scan_msg = LaserScan()
        scan_msg.ranges = [0.2] * 360  # Obstacle everywhere
        self.node.scan_callback(scan_msg)

        cmd_vel = self.node.control_loop_get_command()  # You'd need to implement this
        # Verify turning behavior

        # Test without obstacle
        scan_msg.ranges = [2.0] * 360  # No obstacles
        self.node.scan_callback(scan_msg)

        cmd_vel = self.node.control_loop_get_command()  # You'd need to implement this
        # Verify forward movement behavior

if __name__ == '__main__':
    unittest.main()
```

## Best Practices and Patterns

### Code Organization Patterns

1. **Separation of Concerns**: Separate communication, business logic, and hardware abstraction
2. **Configuration over Code**: Use parameters for configuration rather than hardcoding
3. **Error Isolation**: Isolate error-prone operations to prevent system-wide failures
4. **Resource Management**: Properly manage publishers, subscribers, and timers

### Performance Optimization

1. **Message Filtering**: Process only necessary messages
2. **Efficient Data Structures**: Use appropriate data structures for sensor data
3. **Threading Considerations**: Use multi-threaded executors when appropriate
4. **Memory Management**: Be mindful of message allocation and copying

## Summary

Building real robots in Python with ROS 2 requires a comprehensive understanding of package structure, workspace organization, launch systems, and advanced rclpy programming techniques. Properly structured Python packages with clear dependencies, well-organized workspaces, comprehensive launch files, and robust error handling form the foundation of reliable robotic systems. Advanced techniques like lifecycle nodes, multi-threaded execution, and custom message types enable the development of sophisticated robotic applications. Effective debugging and testing strategies ensure that robotic systems operate reliably in real-world environments.

## Key Takeaways

- ROS 2 Python packages follow a specific structure with package.xml, setup.py, and proper module organization
- Workspaces provide organized environments for multiple related packages
- Launch files enable complex system startup with proper configuration and remapping
- Advanced rclpy techniques include lifecycle nodes, multi-threading, and custom messages
- Robust error handling and debugging are essential for real-world robotic applications
- Testing and validation ensure system reliability and performance

## References and Further Reading

1. ROS 2 Python Client Library (rclpy) Documentation: https://docs.ros.org/en/rolling/p/rclpy/
2. "Programming Robots with ROS" by Morgan Quigley et al.
3. "Effective Python" by Brett Slatkin (for Python best practices)
4. ROS 2 Launch System Documentation: https://docs.ros.org/en/rolling/How-To-Guides/Launch-system-recipes.html